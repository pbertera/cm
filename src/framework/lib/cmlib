#!/bin/sh

#@==================
#@Funzioni Generiche
#@==================
#@
#@Le funzioni in questa sezioni sono ad utilità generica
#@

#@.. function:: __cm_print_help_header(command)
#@   
#@   Stampa l'help header del comando
#@
#@   ``__cm_print_help_header "system interface ethernet eth0 address4"`` produrrà in stdout ::
#@
#@      -----------------------------------------------
#@      Command Help: system interface ethernet eth0 address4
#@      -----------------------------------------------
#@   
#@   :param command: il comando da documentare
#@   :type command: String
#@
__cm_print_help_header()
{
	echo
	echo "-----------------------------------------------"
	echo "Command Help: $@"
	echo "-----------------------------------------------"
	echo
}

#@.. function:: __cm_print_help_bottom()
#@   
#@   Stampa l'help bottom del comando
#@
#@   ``__cm_print_help_bottom`` produrrà in stdout ::
#@
#@      -----------------------------------------------
#@   
__cm_print_help_bottom()
{
	echo
	echo "-----------------------------------------------"
}

#@.. function:: __cm_debug([text],[...])
#@   
#@   Stampa la stringa passata in stderr solo se è impostata la variabile ``__cm_debug``
#@
#@   ``__cm_debug Hello world`` produrrà in stderr ::
#@
#@       Debug: Hello world 
#@   
#@   :param text: la stringa da stampare
#@   :type text: String
#@
__cm_debug()
{
	[ $__cm_debug ] && echo "Debug: $@" 1>&2
	return 0
}

#@.. function:: __cm_exit_error([text],[...])
#@   
#@   Stampa la stringa passata in stderr ed esce
#@
#@   :param text: la stringa da stampare
#@   :type text: String
#@
__cm_exit_error()
{
	echo "Error: $@"  1>&2 
	exit 1
}

#@=======================
#@Commands Management API
#@=======================
#@
#@Le funzioni in questa sezione servono ad estrapolare le varie parti dei comandi (nome, parametri, script, ecc..)
#@

#@.. function:: __cm_command_param(command)
#@   
#@   Stampa i soli parametri che fanno parte della stringa ``command``
#@
#@   :param command: il comando da cui estrarre i parametri
#@   :type command: String
#@
__cm_command_param()
{
	local full_command="$@"
	local command=$(__cm_command $@)
	local command_length=${#command}
	local params=${full_command:${command_length}}
	echo $params
}

#@.. function:: __cm_command_name(command)
#@   
#@   Stampa il solo nome del comando ``command``
#@
#@   :param command: il comando da cui estrarre il nome
#@   :type command: String
#@
__cm_command_name()
{
	local command_path=$(__cm_command_path $@)
	echo $(basename "$command_path")
}

#@.. function:: __cm_command_name(command)
#@   
#@   Stampa il comando completo esclusi i parametri di ``command``
#@
#@   :param command: il comando da cui togliere gli eventuali parametri
#@   :type command: String
#@
__cm_command()
{
	OIFS=$IFS
	IFS=$'\n'
	for line in $(__cm_analyze_command $@); do
		case $line in
			command:*) echo ${line/*:/}
		esac
	done
	IFS=$OIFS
}

#@.. function:: __cm_command_path(command)
#@   
#@   Stampa il path dello script che implementa il comando ``command``
#@
#@   :param command: il comando di cui si vuole conoscere il path del performer. 
#@    Deve essere il coamndo senza parametri
#@   :type command: String
#@
__cm_command_path()
{
	OIFS=$IFS
	IFS=$'\n'
	for line in $(__cm_analyze_command $@); do
		case $line in
			path:*) echo ${line/*:/}
		esac
	done
	IFS=$OIFS
}

#@.. function:: __cm_command_path_dir(command)
#@   
#@   Stampa il nome della directory che contiene lo script che implementa il comando ``command``
#@
#@   :param command: il comando senza parametri
#@   :type command: String
#@
__cm_command_path_dir()
{
	local command_path=$(__cm_command_path $@)
	echo $(dirname "$command_path")
}

#@.. function:: __cm_is_command_leaf(command)
#@   
#@   ritorna 0 se il comando ``command`` è una foglia, altrimenti 1
#@
#@   :param command: il comando senza parametri
#@   :type command: String
#@   :rtype: Integer
#@
__cm_is_command_leaf()
{
        OIFS=$IFS
        IFS=$'\n'
	# use eval for remove quoting
        for line in $(__cm_analyze_command $@ 2>/dev/null); do
                case $line in
                        type:*) [ "${line/*:/}" == "leaf" ] && return 0
                esac
        done
        IFS=$OIFS	
	return 1
}

#@.. function:: __cm_is_command_tag(command)
#@   
#@   ritorna 0 se il comando ``command`` è un nodo tag, altrimenti 1
#@
#@   :param command: il comando senza parametri
#@   :type command: String
#@   :rtype: Integer
#@
__cm_is_command_tag()
{
        OIFS=$IFS
        IFS=$'\n'
        for line in $(__cm_analyze_command $@ 2>/dev/null); do
                case $line in
                        type:*) [ "${line/*:/}" == "tag" ] && return 0
                esac
        done
        IFS=$OIFS	
	return 1
}


#@.. function:: __cm_is_command_node(command)
#@   
#@   ritorna 0 se il comando ``command`` è un ramo, altrimenti 1
#@
#@   :param command: il comando senza parametri
#@   :type command: String
#@   :rtype: Integer
#@
__cm_is_command_node()
{
        OIFS=$IFS
        IFS=$'\n'
        for line in $(__cm_analyze_command $@ 2>/dev/null); do
                case $line in
                        type:*) [ "${line/*:/}" == "node" ] && return 0
                esac
        done
        IFS=$OIFS	
	return 1
}

#@.. function __cm_analyze_command(command)
#@
#@   stampa `type` e `performer` per il comando passato.
#@   `type` puo' essere **tag**, **node** o **leaf** a seconda del tipo di comando
#@
#@   :param command: il comando da analizzare
#@   :type command: string
#@   :rtype: String
__cm_analyze_command()
{
	path="${__cm_libexec_dir}"
	command=
	node_type=
	performer=
	
	while (( "$#" )); do
		cur=${1/ //}
		command="$command $cur"
		#path="$path/${cur/ /}"
		path="$path/${cur}"
		path=${path/ /}
		if [ -d "$path/_tag" ]; then
			node_type=tag
			path="$path/_tag"
			performer="$path/tag"
			completion_helper="$path/_tag_complete"
			syntax_checker="$path/_tag_syntax"
			help_script="$path/_tag_help"
			shift
		elif [ -d "$path" ]; then
			node_type=node
			performer=
			completion_helper=
			syntax_checker=
			help_script=
		elif [ -f "$path" ]; then
			node_type=leaf
			performer="$path"	
			completion_helper="$path/$cur"
			syntax_checker="$path/_$cur_syntax"
			syntax_checker="$path/_$cur_help"
			break
		else
			__cm_exit_error "Command not found: -$command-"
		fi
		shift
	done
	echo command:${command/ /}
	echo type:$node_type
	echo performer:$performer
	echo path:$path
}

__cm_list_node(){
	path=$(__cm_command_path $@)
	__cm_is_command_tag $@
	[ "$?" == "0" ] && return
	for node in $path/*; do
		node=$(basename $node)
		[ "${node:0:1}" != "_" ] && echo $node

	done
}

#@.. function:: __cm_get_command_branch_priority(command_branch)
#@   
#@   stampa la priorità del command branch. Se non trova il file di priorità
#@   stampa la priorità definita dalla variabile ``_cm_default_priority``
#@
#@   :param command_branch: il comando senza parametri
#@   :type command_branch: String
#@   :rtype: Integer
#@
__cm_get_command_branch_priority()
{
	local branch=$@
	local command_dir="$__cm_libexec_dir"/"${@// //}"
	if [ -f "${command_dir}/_priority" ]; then
		cat "$command_dir"/_priority
	else
		echo $__cm_default_priority
		__cm_debug "Priority not found. Priority file: $command_dir/_priority"
	fi
}

#@.. function:: __cm_get_command_branch_priority(command)
#@   
#@   stampa la priorità del comado. Se non trova il file di priorità
#@   stampa la priorità definita dalla variabile ``_cm_default_priority``
#@
#@   :param command: il comando senza parametri
#@   :type command: String
#@   :rtype: Integer
#@
__cm_get_command_priority()
{
	local branch=$@
	command_dir=$(__cm_command_path_dir $@)
	command_name=$(__cm_command_name $@)
	
	if [ -f "${command_dir}/_${command_name}_priority" ]; then
		cat "${command_dir}/_${command_name}_priority"
	else
		echo $__cm_default_priority
		__cm_debug "Priority not found. Priority file: ${command_dir}/_${command_name}_priority"
	fi

	
}
##### DATABSE LIBRARY #######
#@.. _cmdb_api:
#@
#@=====================================
#@Configuration Management Database API
#@=====================================
#@

#@.. function:: __cm_db_create_branch(branch)
#@   
#@   Crea un branch all'interno del CMDB
#@
#@   :param branch: il branch da creare
#@   :type command: String
#@
__cm_db_create_branch()
{
	branch=$@
	__cm_is_command_node $branch
	if [ $? == 0 ]; then
		local path_in_db="$(__cm_db_node_to_path $branch)"
		__cm_debug "Creating branch $path_in_db in database"
		mkdir -p $path_in_db
	else
		__cm_exit_error "Creare branch in db: Command branch not exist: $@"
	fi
}

#@.. function:: __cm_db_set_leaf(value, leaf_path)
#@   
#@   Crea una foglia con path `leaf_path` all'interno del CMDB impostando il valore a `value`. 
#@   Se la foglia esiste già viene sovrascritta. Es.: ::
#@
#@   __cm_db_set_leaf 192.168.101.11 system name-server
#@
#@   imposterà a `192.168.101.11` la foglia `name-server` sotto il path `system`
#@
#@   :param value: il valore da assegnare alla foglia
#@   :param leaf_path: il path della foglia
#@
__cm_db_set_leaf()
{
	local value=$1
	local branch=${@:2:$((${#@} - 2))}
	local leaf=${@:${#@}}
	local path_in_db="$(__cm_db_node_to_path $branch)"
	__cm_is_command_leaf $branch $leaf
	if [ $? == 0 ]; then
		[ -d "$path_in_db" ] || __cm_db_create_branch $branch
		__cm_debug "Setting leaf $path_in_db/$leaf in database"
		echo "$value" > "$path_in_db"/"$leaf"
	else
		__cm_exit_error "Command not exist: $branch $leaf"
	fi
}

#@.. function:: __cm_db_append_leaf(value, leaf_path)
#@   
#@   Aggiunge un valore ad foglia con path `leaf_path` all'interno del CMDB. 
#@   Se la foglia non esiste viene creata. Es.: ::
#@
#@   __cm_db_append_leaf 192.168.101.11/24 interfaces ethernet eth0 address4
#@
#@   imposterà a `192.168.101.11/24` la foglia `address4` sotto il path `interfaces ethernet eth0`
#@
#@   :param value: il valore da aggiungere alla foglia
#@   :param leaf_path: il path della foglia
#@
__cm_db_append_leaf()
{
	local value=$1
	local branch=${@:2:$((${#@} - 2))}
	local leaf=${@:${#@}}
	
	local path_in_db="$(__cm_db_node_to_path $branch)"
	__cm_is_command_leaf $branch $leaf
	if [ $? == 0 ]; then
		[ -d "$path_in_db" ] || __cm_db_create_branch $branch
		__cm_debug "Appending to leaf $path_in_db/$leaf in database"
		echo "$value" >> "$path_in_db"/"$leaf"
	else
		__cm_exit_error "Command not exist: $branch $leaf"
	fi

}

#@.. function:: __cm_db_get_leaf(leaf_path)
#@   
#@   Stampa il valore della foglia con path `leaf_path` all'interno del CMDB. 
#@
#@   __cm_db_get_leaf interfaces ethernet eth0 address4
#@
#@   stamperà il contenuto della foglia `address4` sotto il path `interfaces ethernet eth0`
#@
#@   :param leaf_path: il path della foglia
#@
__cm_db_get_leaf()
{	
	local branch="$@"
	#local leaf_path_in_db="$__cm_db_dir"/"${leaf_path// //}"
	local path=$(__cm_db_node_to_path $branch)
	__cm_db_is_leaf "$branch"
	if [ $? == 0 ];then 
		cat "$path"
	else
		__cm_exit_error "the configuration leaf \"$branch\" not exist in db"
	fi
}

#@.. function:: __cm_db_list_nodes_sorted_priority(node_path)
#@   
#@   Elenca i nodi figli di `node_path` ordinati per priorità all'interno del CMDB.
#@   Viene stampata anche la priorità
#@
#@   :param node_path: il path del node
#@
__cm_db_list_nodes_sorted_priority()
{
	branch=${@}
	start_path=$(__cm_db_node_to_path $branch)
	if [ -d "$start_path" ];then
		for b in $start_path/*; do
			[ -d "$b" ] || continue
			branch=$(basename $b)
			priority=$(__cm_get_command_branch_priority "$@ $branch")
			ret="$priority:${@} $branch"
			echo ${ret/: /:}
		done | sort -n -k1 -t:
	else
		__cm_exit_error "the configuration path \"$branch\" not exist in db"
	fi
} 

#@.. function:: __cm_db_list_nodes_sorted(node_path)
#@   
#@   Elenca i nodi figli di `node_path` ordinati per priorità all'interno del CMDB.
#@
#@   :param node_path: il path del nodo
#@
__cm_db_list_nodes_sorted()
{ 
	__cm_db_list_nodes_sorted_priority $@ | cut -d: -f2
}

#@.. function:: __cm_db_node_to_path(node_path)
#@   
#@   Stampa il path del filesystem associato a `node_path`.
#@
#@   :param node_path: il path del node
#@
__cm_db_node_to_path()
{
	local branch=$@
	local start_path="$__cm_db_dir"
	local branch_path=${start_path}/${branch// //}
	echo $branch_path
}

#@.. function:: __cm_db_list_leaf_sorted(node_path)
#@   
#@   Elenca le foglie figlie di `node_path` ordinate per priorità all'interno del CMDB.
#@   Viene stampata anche la priorità
#@
#@   :param branch_path: il path del node
#@
__cm_db_list_leaf_sorted_priority()
{
	local branch=$@
	local path=$(__cm_db_node_to_path $branch)
	for leaf_name in $( ls -1 $path); do
		__cm_db_is_leaf "$branch $leaf_name"
		if [ $? == 0 ]; then
			priority=$(__cm_get_command_priority "$branch $leaf_name")
			echo "${priority}:$leaf_name"
			__cm_debug "$leaf_name is a leaf, priority is: $priority"
		fi
	done | sort -n -k1 -t:
}

#@.. function:: __cm_db_list_leaf_sorted(node_path)
#@   
#@   Elenca le foglie figlie di `node_path` ordinate per priorità all'interno del CMDB.
#@
#@   :param branch_path: il path del node
#@
__cm_db_list_leaf_sorted()
{
	__cm_db_list_leaf_sorted_priority $@ | cut -d: -f2-
}


#@.. function:: __cm_db_is_leaf(leaf_path)
#@   
#@   ritorna 0 se la foglia ``leaf_path`` è una foglia, altrimenti 1
#@
#@   :param leaf_path: la voglia da verificare
#@   :type leaf_path: String
#@   :rtype: Integer
#@
__cm_db_is_leaf()
{
	local branch=$@
	local path=$(__cm_db_node_to_path $branch)
	local filename=$(basename $path)

	[ "${filename:0:1}" == "_" ] && return 1
	[ -f "$path" ] && return 0 	
}

#@.. function:: __cm_db_show_tree([branch_path])
#@   
#@   Stampa un albero del CMDB partendo da `branch_path` ordinato per priorità.
#@
#@   :param branch_path: il path del branch
#@
__cm_db_show_tree()
{
	local tree=
	if [ -n "$@" ]; then
		tree="$@"
	fi
	OIFS=$IFS
	IFS=$'\n'
	for branch in $(__cm_db_list_nodes_sorted $tree); do
		for leaf_name in $(__cm_db_list_leaf_sorted $branch); do
			__cm_db_is_leaf "$branch $leaf_name"
			[ $? == 1 ] && continue
			val=$(__cm_db_get_leaf "$branch $leaf_name")
			for v in $val; do
				__cm_debug "Leaf: $branch ${leaf_name}, value: $v"
				echo "$branch $leaf_name $v"
			done
			[ -z "${val}" ] && echo "$branch $leaf_name"
		done
		__cm_db_show_tree $branch
	done
	IFS=$OIFS
}
	
# remove leaf from db: the arguments represent the path of leaf
#@.. function:: __cm_db_remove_leaf(leaf_path)
#@   
#@   Rimuove la foglia `leaf_path` dal CMDB.
#@
#@   :param leaf_path: il path della foglia
#@
__cm_db_remove_leaf()
{
	local leaf_path=$@
	local leaf_path_in_db="$__cm_db_dir"/"${leaf_path// //}"
	if [ -f "$leaf_path_in_db" ]; then
		rm -f "$leaf_path_in_db"
	else
		__cm_exit_error "the configuration path \"$leaf_path\" not exist in db"
	fi

}

# remove branch from db: the arguments represent the path of branch
#@.. function:: __cm_db_remove_branch(branch_path)
#@   
#@   Rimuove il branch `branch_path` dal CMDB.
#@
#@   :param branch_path: il path del branch
#@
__cm_db_remove_branch()
{
	local branch_path=$@
	local branch_path_in_db="$__cm_db_dir"/"${branch_path// //}"
	if [ -d "$branch_path_in_db" ]; then
		rm -rf "$branch_path_in_db"
	else
		__cm_exit_error "the configuration path \"$branch_path\" not exist in db"
	fi

}

#@.. function:: __cm_show_conf[branch_path])
#@   
#@   Stampa un albero del CMDB partendo da `branch_path` ordinato per priorità.
#@   A differenza di `__cm_db_show_tree` antepone il nome del comando prendendolo dalla variabile `__cm_bin`
#@
#@   :param branch_path: il path del branch
#@
__cm_show_conf()
{
	OIFS=$IFS
	IFS=$'\n'

	for conf in $(__cm_db_show_tree $@); do
        	echo $__cm_bin $conf
	done

	IFS=$IFS
}
